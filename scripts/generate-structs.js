const fs = require("fs");
const get = require("lodash.get");
const pb = require("protobufjs");
const snakeCase = require("lodash.snakecase");
const DepGraph = require("dependency-graph").DepGraph;

function snakeCaseGads(str) {
  const snaked = snakeCase(str);
  const last_character = snaked[snaked.length - 1];
  if (!isNaN(+last_character)) {
    return snaked.slice(0, snaked.length - 2) + last_character;
  }
  return snaked;
}

const COMPILED_ENUMS_FILEPATH = process.argv[2];
const API_VERSION = process.argv[3];
const OUT_FILE = process.argv[4];
const BASE_PATH = `google.ads.googleads.${API_VERSION}`;

const file = require(__dirname + `/${COMPILED_ENUMS_FILEPATH}`);
const resources = getProtobufRoot(`${BASE_PATH}.resources`);
const common = getProtobufRoot(`${BASE_PATH}.common`);
const services = getProtobufRoot(`${BASE_PATH}.services`);

const stream = fs.createWriteStream(OUT_FILE);
const root = pb.loadSync(__dirname + `/${COMPILED_ENUMS_FILEPATH}`);

const pbToTsMapping = {
  bool: "boolean",
  "google.protobuf.BoolValue": "boolean",

  int64: "number",
  int32: "number",
  "google.protobuf.Int64Value": "number",
  "google.protobuf.Int32Value": "number",
  "google.protobuf.UInt64Value": "number",
  float: "number",
  "google.protobuf.FloatValue": "number",
  double: "number",
  "google.protobuf.DoubleValue": "number",

  bytes: "string",
  string: "string",
  "google.protobuf.StringValue": "string",
  "google.protobuf.BytesValue": "string",
};

const enumImports = new Set();
const scopedInterfaces = [];
const entitiesWithEnumsOnly = [];
const circularDependencies = {};

stream.write("/* Autogenerated File! Do Not Edit. */\n");

stream.write(`
    const string = "string";
    const boolean = "boolean";
    const number = "number";
  `);

/* Compile core types */
translateEntities(common, getOrderedKeys(common));
translateEntities(resources, getOrderedKeys(resources));
translateEntities(services, getOrderedKeys(services));

/* Close stream */
stream.end();

function resolveNestedNodes(entity, set) {
  if (set.has(entity.name)) {
    return set;
  }
  set.add(entity.name);
  if (entity.nested) {
    for (const i in entity.nested) {
      resolveNestedNodes(entity.nested[i], set);
    }
  }
  return set;
}

function resolveNestedDependencies(entity, parentEntity, graph) {
  if (!graph.hasNode(entity.name)) {
    return;
  }
  if (parentEntity) {
    graph.addDependency(parentEntity.name, entity.name);
  }
  for (const field in entity.fields) {
    const fieldType = entity.fields[field].type;
    if (graph.hasNode(fieldType)) {
      graph.addDependency(entity.name, fieldType);
    }
  }
  if (entity.nested) {
    for (const i in entity.nested) {
      const nestedEntity = root.lookup(entity.nested[i].name);
      resolveNestedDependencies(nestedEntity, entity, graph);
    }
  }
}

function resolveCircularDependencies(graph) {
  while (true) {
    try {
      graph.overallOrder();
      break;
    } catch (err) {
      const from = root.lookup(err.cyclePath[err.cyclePath.length - 2]);
      const to = root.lookup(err.cyclePath[err.cyclePath.length - 1]);

      graph.removeDependency(from.name, to.name);

      if (!circularDependencies[to.name]) {
        circularDependencies[to.name] = {};
      }
      circularDependencies[to.name][from.name] = from;
    }
  }
}

function getOrderedKeys(entities) {
  const graph = new DepGraph();

  const nodesSet = new Set();
  for (const i in entities) {
    resolveNestedNodes(root.lookup(i), nodesSet);
  }
  Array.from(nodesSet)
    .sort()
    .forEach(node => graph.addNode(node));

  for (const i in entities) {
    resolveNestedDependencies(root.lookup(i), null, graph);
  }

  resolveCircularDependencies(graph);

  return graph.overallOrder();
}

function findFieldNamesByType(entity, fieldType) {
  return Object.keys(entity.fields).filter(key => entity.fields[key].type === fieldType);
}

function buildNestedInterfaces(entity) {
  if (entity.nestedArray && entity.nestedArray.length > 0) {
    for (const nested of entity.nestedArray) {
      buildNestedInterfaces(nested);
    }
  }
  stream.write("\n");
  buildInterfaceType(entity);
}

function translateEntities(entities, keys = Object.keys(entities)) {
  for (const i of keys) {
    const entity = root.lookup(i);

    if (entity.comment) {
      stream.write(`/* ${entity.comment} */\n`);
    }

    const isUnionType = !!entity.oneofs && entity.oneofs.value;
    if (isUnionType) {
      buildUnionType(entity);
      stream.write("\n");
      continue;
    }
    buildNestedInterfaces(entity);
  }
}

function buildUnionType(entity) {
  stream.write(`\nexport const ${entity.name} = {\n`);

  for (let i = 0; i < entity.fieldsArray.length; i++) {
    const field = entity.fieldsArray[i];
    const isFinalField = i === entity.fieldsArray.length - 1;

    const key = `${snakeCaseGads(field.name)}`;
    const translated = translateType(field, field.name, entity.parent);

    if (translated.isEnum) {
      enumImports.add(translated.type);
    }

    let line = `${key}: ${translated.type} `;
    if (!isFinalField) line += `,\n`;

    stream.write(line);
  }

  stream.write(`\n}\n`);
}

function buildInterfaceType(entity) {
  stream.write(`/* ${entity.fullName} */\n`);
  stream.write(`// @ts-ignore\n`);
  stream.write(`export const ${entity.name} = {\n`);

  scopedInterfaces.push(entity.name);

  for (const f in entity.fields) {
    const field = entity.fields[f];

    let key = snakeCaseGads(field.name);
    let translated = translateType(field, f, entity.parent);
    let type = translated.type;

    let t = type;
    if (translated.isEnum) {
      t = `"enum_${type}"`;
    }
    /* Delay initialization until circular dependency will be defined */
    if (circularDependencies[t] && circularDependencies[t][entity.name]) {
      t = `null`;
    }
    stream.write(`\n// @ts-ignore\n${key}: ${t},\n`);
  }

  stream.write(`}\n`);

  /* Finalize delayed initialization  */
  if (circularDependencies[entity.name]) {
    for (const i in circularDependencies[entity.name]) {
      const dependant = circularDependencies[entity.name][i];
      const fields = findFieldNamesByType(dependant, entity.name);
      fields.forEach(fieldName => {
        stream.write(
          `\n// @ts-ignore\n${dependant.name}.${snakeCaseGads(fieldName)} = ${entity.name};\n`
        );
      });
    }
  }

  /* Build resource objects with only enum properties */
  buildEntityWithEnumsOnly(entity);
}

function buildEntityWithEnumsOnly(entity) {
  if (entity.fullName.includes("services")) {
    return;
  }

  let entityWithEnumsOnly = `\n/* ${entity.fullName} */\nexport const ${snakeCaseGads(
    entity.name
  )} = {\n`;

  for (const f in entity.fields) {
    const field = entity.fields[f];

    let key = snakeCaseGads(field.name);
    let translated = translateType(field, f, entity.parent);
    let type = translated.type;

    if (scopedInterfaces.includes(type)) {
      if (key === snakeCaseGads(type)) {
        entityWithEnumsOnly += `${key},\n`;
      } else {
        entityWithEnumsOnly += `${key}: ${snakeCaseGads(type)},\n`;
      }
      continue;
    }

    if (translated.isEnum) {
      entityWithEnumsOnly += `${key}: "${type}",\n`;
    }
  }

  entityWithEnumsOnly += `}\n`;
  entitiesWithEnumsOnly.push(entityWithEnumsOnly);
}

function translateType(field, key, parent) {
  const { type } = field;

  const mapping = pbToTsMapping[type];
  if (mapping) {
    return { type: mapping, isEnum: false };
  }

  const lookup = root.lookupTypeOrEnum(type);

  /* When the type is defined in the parent */
  if (scopedInterfaces.includes(lookup.name)) {
    return { type: lookup.name, isEnum: false };
  }
  if (
    lookup.parent &&
    field.parent &&
    lookup.parent.parent.name !== "common" &&
    lookup.parent.name === field.parent.name
  ) {
    return { type: field.type, isEnum: false };
  }

  if (lookup.parent.name === "common") {
    /* If it's a common type */
    return { type: lookup.name, isEnum: false };
  }

  /* It it's an enum type (already compiled) */
  if (lookup.fullName.includes("enums")) {
    return { type: lookup.name, isEnum: true };
  }

  if (lookup.fields) {
    let objType = "";

    for (const item of lookup.fieldsArray) {
      if (!item) return { type: "undefined", isEnum: false };
      let type = pbToTsMapping[item.type];

      //   if (!type) {
      const translated = translateType({ type: item.type }, key, parent);
      type = translated.type;
      //   }
      let itemKey = snakeCaseGads(item.name);
      objType += `${itemKey}: ${translated.isEnum ? `"enum_${type}"` : type},\n`;
    }
    return { type: `{${objType}}`, isEnum: false };
  }

  return { type: "undefined", isEnum: false };
}

function getProtobufRoot(path) {
  const nestedPath = path.split(".").join(".nested.");
  return get(file, `nested.${nestedPath}.nested`);
}
