const startCase = require("lodash.startcase");
const get = require("lodash.get");
const isObject = require("lodash.isobject");

const fs = require("fs");
const { GoogleAdsClient } = require("../build/index");
const {
  SearchGoogleAdsFieldsRequest,
  SearchGoogleAdsFieldsResponse,
  GoogleAdsFieldCategoryEnum,
} = require("../build/lib/types");

const { GoogleAdsRow } = require("./../src/lib/struct");

/* 
  This file is used for generating "fields.ts".
  It should only be run when updating the Google Ads API version
*/

const CLIENT_ID = process.env.GADS_NODE_CLIENT_ID;
const CLIENT_SECRET = process.env.GADS_NODE_CLIENT_SECRET;
const REFRESH_TOKEN = process.env.GADS_NODE_REFRESH_TOKEN;
const DEVELOPER_TOKEN = process.env.GADS_NODE_DEVELOPER_TOKEN;

const client = new GoogleAdsClient({
  client_id: CLIENT_ID,
  client_secret: CLIENT_SECRET,
  refresh_token: REFRESH_TOKEN,
  developer_token: DEVELOPER_TOKEN,
  parseResults: true,
});

const service = client.getService("GoogleAdsFieldService");
const stream = fs.createWriteStream(__dirname + "/../src/lib/fields.ts");

async function main() {
  const { resultsList } = await getAllFields();
  const resources = {};
  const resourceMetrics = {};
  const resourceSegments = {};
  const segments = [];
  const allMetrics = [];

  for (const row of resultsList) {
    if (isResource(row.category)) {
      resources[row.name] = [];

      /* Find selectable with attributes for the resource */
      const selectableWith = Object.values(row.selectableWith).filter(
        val => !val.includes("segments.") && !val.includes("metrics.")
      );
      for (const selectableResource of selectableWith) {
        const selectableAttributes = resultsList.filter(r => {
          return isAttribute(r.category) && r.resourceName.includes(`/${selectableResource}.`);
        });
        for (const selectableWithRow of selectableAttributes) {
          resources[row.name].push(selectableWithRow);
        }
      }

      /* Save the metrics */
      if (!resourceMetrics.hasOwnProperty(row.name)) {
        resourceMetrics[row.name] = [];
      }
      for (const metric in row.metrics) {
        resourceMetrics[row.name].push(row.metrics[metric]);
      }

      /* Save the segments */
      if (!resourceSegments.hasOwnProperty(row.name)) {
        resourceSegments[row.name] = [];
      }
      for (const segment in row.segments) {
        resourceSegments[row.name].push(row.segments[segment]);
      }
    }

    if (isAttribute(row.category)) {
      const resourceName = row.name.split(".")[0];
      resources[resourceName].push(row);
    }
    if (isSegment(row.category)) {
      segments.push(row);
    }
    if (isMetric(row.category)) {
      allMetrics.push(row);
    }
  }

  stream.write(`/* Autogenerated File! Do Not Edit */\n`);
  stream.write(`import * as enums from './enums'\n`);

  /* RESOURCES */
  stream.write(`\n/*\n  -- RESOURCES --\n*/\n`);

  /* Resource names */
  buildUnionArray(Object.keys(resources), "ResourceName");
  let all_resources_interface = `interface AllArgs {\n`;
  for (const resource in resources) {
    stream.write(`\n\n/*\n --- Start of ${toTypeCase(resource)} ---\n*/`);

    const fields = resources[resource];
    if (!fields) continue;

    /* Field values */
    stream.write(`\n// @ts-ignore\nexport const ${resource} = [\n`);
    for (const field of fields) {
      if (!field.selectable) {
        continue;
      }
      stream.write(`"${field.name}",\n`);
    }
    stream.write(`]\n\n`);

    /* Field types */
    buildUnionArray(
      fields.filter(f => f.selectable),
      `${toTypeCase(resource)}Field`
    );

    /* Per resource metrics */
    const metrics = resourceMetrics[resource];
    if (metrics && metrics.length > 0) {
      buildUnionArray(metrics, `${toTypeCase(resource)}Metric`);
    }

    /* Per resource segments */
    const segments = resourceSegments[resource];
    if (segments && segments.length > 0) {
      buildUnionArray(segments, `${toTypeCase(resource)}Segment`);
    }
    stream.write(`\n
    export interface ${toTypeCase(resource)}Args {
      attributes: ${toTypeCase(resource)}FieldFull
      segments: ${toTypeCase(resource)}SegmentFull
      metrics: ${toTypeCase(resource)}MetricFull
    }
    `);

    all_resources_interface += `${resource}: ${toTypeCase(resource)}Args,\n`

    stream.write(`\n/*\n --- End of ${toTypeCase(resource)} ---\n*/`);
  }

  all_resources_interface += `}\n`
  stream.write(`\n/*\n  -- ALL RESOURCE REPORT ARGS --\n*/\n\n`);
  stream.write(all_resources_interface);

  /* SEGMENTS */
  stream.write(`\n/*\n  -- SEGMENTS --\n*/`);
  buildUnionArray(segments, "Segment");

  /* METRICS */
  stream.write(`\n/*\n  -- METRICS --\n*/`);
  buildUnionArray(allMetrics, "Metric");

  stream.end();
}

function buildUnionArray(fields, unionName, arrayName = "") {
  stream.write(`\nexport type ${unionName}Full = {\n`);
  for (const field of fields) {
    const name = field.name || field;

    let type = get(GoogleAdsRow, name);

    if (field.isRepeated) {
      type = "Array<" + objectToString(type) + ">";
    } else {
      type = objectToString(type);
    }

    const name_array = name.split(".");
    let o = type;
    let t;
    while ((t = name_array.pop())) {
      o = `{${t}: ${o}}`;
    }

    let s = `"${name}" : ${o}`;

    stream.write(s + ",\n");
  }
  stream.write("}\n");

  stream.write(`\n\nexport type ${unionName} = keyof ${unionName}Full\n`);
  stream.write(`\n\nexport type ${arrayName || unionName}s = Array<${unionName}>\n`);
}

function objectToString(o) {
  let s = ``;
  function eachRecursive(obj) {
    s = `${s}{`;
    for (var k in obj) {
      if (isObject(obj[k])) {
        s = `${s} ${k}: `;
        eachRecursive(obj[k]);
      } else {
        s = `${s} ${k}: ${convertToEnumString(obj[k])},`;
      }
    }
    s = `${s}},`;
  }

  if (!isObject(o)) {
    return convertToEnumString(o);
  }

  eachRecursive(o);
  return s;
}

function convertToEnumString(s) {
  if (typeof s === "string" && s.includes("enum_")) {
    return s.replace("enum_", "enums.");
  }
  return s;
}

function isResource(category) {
  return category === GoogleAdsFieldCategoryEnum.GoogleAdsFieldCategory.RESOURCE;
}

function isAttribute(category) {
  return category === GoogleAdsFieldCategoryEnum.GoogleAdsFieldCategory.ATTRIBUTE;
}

function isSegment(category) {
  return category === GoogleAdsFieldCategoryEnum.GoogleAdsFieldCategory.SEGMENT;
}

function isMetric(category) {
  return category === GoogleAdsFieldCategoryEnum.GoogleAdsFieldCategory.METRIC;
}

function toTypeCase(str) {
  return startCase(str).replace(/\s/g, "");
}

async function getAllFields() {
  const request = new SearchGoogleAdsFieldsRequest();
  request.setQuery(`
    SELECT 
      name,
      category,
      selectable,
      selectable_with,
      attribute_resources,
      filterable,
      metrics,
      segments,
      is_repeated
  `);
  /* Other possible fields */
  // selectable_with,
  // attribute_resources,
  // metrics,
  // segments

  const response = await new Promise(resolve => {
    service.searchGoogleAdsFields(request, (_error, results) => {
      resolve(results);
    });
  });
  // console.log(response);
  return response;
}

main();
